using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace LoMapper.Generator;

/// <summary>
/// Emits the generated mapping code for a mapper class.
/// </summary>
internal sealed class MappingCodeEmitter
{
    private readonly Compilation _compilation;
    private readonly SourceProductionContext _context;
    private readonly MapperClassInfo _mapper;
    private readonly StringBuilder _sb = new();
    private int _indentLevel;

    // Cache for available mapper methods in this class (for nested mapping)
    private readonly Dictionary<(string Source, string Target), string> _availableMappers = new();

    public MappingCodeEmitter(
        Compilation compilation,
        SourceProductionContext context,
        MapperClassInfo mapper)
    {
        _compilation = compilation;
        _context = context;
        _mapper = mapper;

        // Index available mapper methods (strip nullability for matching)
        foreach (var method in mapper.Methods)
        {
            var sourceTypeName = GetTypeNameWithoutNullability(method.SourceType);
            var targetTypeName = GetTypeNameWithoutNullability(method.TargetType);
            _availableMappers[(sourceTypeName, targetTypeName)] = method.MethodName;
        }
    }

    private static string GetTypeNameWithoutNullability(ITypeSymbol type)
    {
        // Get the non-nullable version of the type
        var underlyingType = type.WithNullableAnnotation(NullableAnnotation.None);
        return underlyingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat
            .WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.None));
    }

    public string Emit()
    {
        _sb.Clear();
        _indentLevel = 0;

        // File header
        AppendLine("// <auto-generated/>");
        AppendLine("#nullable enable");
        AppendLine();

        // Namespace
        if (_mapper.Namespace is not null)
        {
            AppendLine($"namespace {_mapper.Namespace}");
            AppendLine("{");
            _indentLevel++;
        }

        // Class declaration
        var accessibility = GetAccessibilityString(_mapper.Accessibility);
        AppendLine($"{accessibility} partial class {_mapper.ClassName}");
        AppendLine("{");
        _indentLevel++;

        // Generate each mapping method
        for (int i = 0; i < _mapper.Methods.Length; i++)
        {
            if (i > 0)
            {
                AppendLine();
            }
            EmitMethod(_mapper.Methods[i]);
        }

        _indentLevel--;
        AppendLine("}");

        if (_mapper.Namespace is not null)
        {
            _indentLevel--;
            AppendLine("}");
        }

        return _sb.ToString();
    }

    private void EmitMethod(MapperMethodInfo method)
    {
        var accessibility = GetAccessibilityString(method.Accessibility);
        var returnType = method.TargetType.ToDisplayString();
        var paramType = method.SourceType.ToDisplayString();
        var paramName = method.ParameterName;

        AppendLine($"{accessibility} partial {returnType} {method.MethodName}({paramType} {paramName})");
        AppendLine("{");
        _indentLevel++;

        // Null check - return null for null input
        if (method.TargetType.IsReferenceType || method.TargetType.NullableAnnotation == NullableAnnotation.Annotated)
        {
            AppendLine($"if ({paramName} is null) return null!;");
            AppendLine();
        }

        // Build property mappings
        var mappings = BuildPropertyMappings(method);

        // Build flatten mappings
        var flattenMappings = BuildFlattenMappings(method);

        // Check for constructor-based initialization
        var targetConstructor = GetBestConstructor(method.TargetType, mappings);

        if (targetConstructor is not null && targetConstructor.Parameters.Length > 0)
        {
            EmitConstructorBasedMapping(method, mappings, targetConstructor, flattenMappings);
        }
        else
        {
            EmitPropertyBasedMapping(method, mappings, flattenMappings);
        }

        _indentLevel--;
        AppendLine("}");
    }

    private List<FlattenMapping> BuildFlattenMappings(MapperMethodInfo method)
    {
        var flattenMappings = new List<FlattenMapping>();
        var targetProperties = GetAllProperties(method.TargetType)
            .ToDictionary(p => p.Name, p => p, StringComparer.OrdinalIgnoreCase);

        foreach (var flatten in method.FlattenMappings)
        {
            // Validate target property exists
            if (!targetProperties.TryGetValue(flatten.TargetProperty, out var targetProp))
            {
                _context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.FlattenTargetNotFound,
                    Location.None,
                    flatten.TargetProperty,
                    method.TargetType.Name));
                continue;
            }

            // Skip read-only properties
            if (targetProp.SetMethod is null || targetProp.SetMethod.DeclaredAccessibility == Accessibility.Private)
            {
                continue;
            }

            // Resolve nested property path
            var resolvedType = ResolveNestedPropertyPath(method.SourceType, flatten.SourcePropertyPath, out var isValid);
            if (!isValid || resolvedType is null)
            {
                _context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.InvalidFlattenPath,
                    Location.None,
                    flatten.SourcePropertyPath,
                    method.SourceType.Name,
                    GetLastPropertyNameFromPath(flatten.SourcePropertyPath)));
                continue;
            }

            // Check type compatibility
            if (!IsTypeCompatible(resolvedType, targetProp.Type))
            {
                _context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.FlattenTypeMismatch,
                    Location.None,
                    flatten.SourcePropertyPath,
                    resolvedType.Name,
                    targetProp.Type.Name));
                continue;
            }

            flattenMappings.Add(new FlattenMapping(flatten.SourcePropertyPath, targetProp, resolvedType));
        }

        return flattenMappings;
    }

    private ITypeSymbol? ResolveNestedPropertyPath(ITypeSymbol sourceType, string propertyPath, out bool isValid)
    {
        isValid = true;
        var parts = propertyPath.Split('.');
        var currentType = sourceType;

        foreach (var part in parts)
        {
            var properties = GetAllProperties(currentType);
            var prop = properties.FirstOrDefault(p => string.Equals(p.Name, part, StringComparison.OrdinalIgnoreCase));

            if (prop is null)
            {
                isValid = false;
                return null;
            }

            currentType = prop.Type;
        }

        return currentType;
    }

    private string GetLastPropertyNameFromPath(string propertyPath)
    {
        var parts = propertyPath.Split('.');
        return parts.Length > 0 ? parts[^1] : propertyPath;
    }

    private bool IsTypeCompatible(ITypeSymbol source, ITypeSymbol target)
    {
        // Same type
        if (SymbolEqualityComparer.Default.Equals(source, target))
            return true;

        // Check for implicit/explicit conversion
        var conversions = _compilation.ClassifyConversion(source, target);
        return conversions.IsImplicit || conversions.IsExplicit;
    }

    private List<PropertyMapping> BuildPropertyMappings(MapperMethodInfo method)
    {
        var mappings = new List<PropertyMapping>();
        var sourceProperties = GetAllProperties(method.SourceType)
            .ToDictionary(p => p.Name, p => p, StringComparer.OrdinalIgnoreCase);
        var targetProperties = GetAllProperties(method.TargetType);

        // Build lookup for custom mappings
        var customMappings = method.PropertyMappings
            .ToDictionary(m => m.TargetProperty, m => m, StringComparer.OrdinalIgnoreCase);

        // Build set of properties that will be handled by flatten mappings
        var flattenTargets = new HashSet<string>(
            method.FlattenMappings.Select(f => f.TargetProperty),
            StringComparer.OrdinalIgnoreCase);

        foreach (var targetProp in targetProperties)
        {
            // Skip ignored properties
            if (method.IgnoredProperties.Contains(targetProp.Name))
            {
                continue;
            }

            // Skip flatten-mapped properties (will be handled separately)
            if (flattenTargets.Contains(targetProp.Name))
            {
                continue;
            }

            // Skip read-only properties (no setter)
            if (targetProp.SetMethod is null || targetProp.SetMethod.DeclaredAccessibility == Accessibility.Private)
            {
                continue;
            }

            // Check for custom mapping
            if (customMappings.TryGetValue(targetProp.Name, out var customMapping))
            {
                if (sourceProperties.TryGetValue(customMapping.SourceProperty, out var sourceProp))
                {
                    mappings.Add(new PropertyMapping(
                        sourceProp,
                        targetProp,
                        customMapping.Transform));
                }
                else
                {
                    // Report error: source property not found
                    _context.ReportDiagnostic(Diagnostic.Create(
                        Diagnostics.SourcePropertyNotFound,
                        Location.None,
                        customMapping.SourceProperty,
                        method.SourceType.Name));
                }
                continue;
            }

            // Try to find matching source property by name (case-insensitive)
            if (sourceProperties.TryGetValue(targetProp.Name, out var matchingSource))
            {
                mappings.Add(new PropertyMapping(matchingSource, targetProp, null));
            }
            else
            {
                // Report warning: unmapped property
                _context.ReportDiagnostic(Diagnostic.Create(
                    Diagnostics.UnmappedTargetProperty,
                    Location.None,
                    targetProp.Name,
                    method.TargetType.Name,
                    method.SourceType.Name));
            }
        }

        return mappings;
    }

    private void EmitPropertyBasedMapping(MapperMethodInfo method, List<PropertyMapping> mappings, List<FlattenMapping> flattenMappings)
    {
        var returnType = method.TargetType.ToDisplayString();
        AppendLine($"return new {returnType}");
        AppendLine("{");
        _indentLevel++;

        var allMappingCount = mappings.Count + flattenMappings.Count;
        var currentIndex = 0;

        for (int i = 0; i < mappings.Count; i++, currentIndex++)
        {
            var mapping = mappings[i];
            var assignment = GetPropertyAssignment(mapping, method.ParameterName);
            var comma = currentIndex < allMappingCount - 1 ? "," : "";
            AppendLine($"{mapping.Target.Name} = {assignment}{comma}");
        }

        for (int i = 0; i < flattenMappings.Count; i++, currentIndex++)
        {
            var flatten = flattenMappings[i];
            var assignment = GetFlattenAssignment(flatten, method.ParameterName);
            var comma = currentIndex < allMappingCount - 1 ? "," : "";
            AppendLine($"{flatten.Target.Name} = {assignment}{comma}");
        }

        _indentLevel--;
        AppendLine("};");
    }

    private void EmitConstructorBasedMapping(
        MapperMethodInfo method,
        List<PropertyMapping> mappings,
        IMethodSymbol constructor,
        List<FlattenMapping> flattenMappings)
    {
        var returnType = method.TargetType.ToDisplayString();
        var ctorParams = new List<string>();
        var remainingMappings = new List<PropertyMapping>(mappings);
        var remainingFlattens = new List<FlattenMapping>(flattenMappings);

        // Match constructor parameters to mappings
        foreach (var param in constructor.Parameters)
        {
            var mapping = remainingMappings.FirstOrDefault(m =>

                string.Equals(m.Target.Name, param.Name, StringComparison.OrdinalIgnoreCase));

            if (mapping is not null)
            {
                ctorParams.Add(GetPropertyAssignment(mapping, method.ParameterName));
                remainingMappings.Remove(mapping);
            }
            else
            {
                ctorParams.Add("default!");
            }
        }

        // If we have remaining properties or flattens, use object initializer
        if (remainingMappings.Count > 0 || remainingFlattens.Count > 0)
        {
            AppendLine($"return new {returnType}({string.Join(", ", ctorParams)})");
            AppendLine("{");
            _indentLevel++;

            var allRemaining = remainingMappings.Count + remainingFlattens.Count;
            var currentIndex = 0;

            for (int i = 0; i < remainingMappings.Count; i++, currentIndex++)
            {
                var mapping = remainingMappings[i];
                var assignment = GetPropertyAssignment(mapping, method.ParameterName);
                var comma = currentIndex < allRemaining - 1 ? "," : "";
                AppendLine($"{mapping.Target.Name} = {assignment}{comma}");
            }

            for (int i = 0; i < remainingFlattens.Count; i++, currentIndex++)
            {
                var flatten = remainingFlattens[i];
                var assignment = GetFlattenAssignment(flatten, method.ParameterName);
                var comma = currentIndex < allRemaining - 1 ? "," : "";
                AppendLine($"{flatten.Target.Name} = {assignment}{comma}");
            }

            _indentLevel--;
            AppendLine("};");
        }
        else
        {
            AppendLine($"return new {returnType}({string.Join(", ", ctorParams)});");
        }
    }

    private string GetPropertyAssignment(PropertyMapping mapping, string paramName)
    {
        var sourceAccess = $"{paramName}.{mapping.Source.Name}";

        // Custom transform
        if (mapping.Transform is not null)
        {
            return $"{mapping.Transform}({sourceAccess})";
        }

        var sourceType = mapping.Source.Type;
        var targetType = mapping.Target.Type;

        // Same type - direct assignment
        if (SymbolEqualityComparer.Default.Equals(sourceType, targetType))
        {
            return sourceAccess;
        }

        // Check if it's a collection mapping
        var collectionMapping = TryGetCollectionMapping(sourceType, targetType, sourceAccess);
        if (collectionMapping is not null)
        {
            return collectionMapping;
        }

        // Check if we have a nested mapper (strip nullability for lookup)
        var sourceTypeName = GetTypeNameWithoutNullability(sourceType);
        var targetTypeName = GetTypeNameWithoutNullability(targetType);

        if (_availableMappers.TryGetValue((sourceTypeName, targetTypeName), out var mapperMethod))
        {
            return $"{sourceAccess} is null ? null! : {mapperMethod}({sourceAccess})";
        }

        // Implicit conversion possible?
        if (_compilation is CSharpCompilation csharpCompilation)
        {
            var conversion = csharpCompilation.ClassifyConversion(sourceType, targetType);
            if (conversion.IsImplicit)
            {
                return sourceAccess;
            }

            // Explicit conversion with cast
            if (conversion.IsExplicit)
            {
                return $"({targetType.ToDisplayString()}){sourceAccess}";
            }
        }

        // Report error: type mismatch with no available conversion
        _context.ReportDiagnostic(Diagnostic.Create(
            Diagnostics.MissingNestedMapper,
            Location.None,
            mapping.Target.Name,
            sourceTypeName,
            targetTypeName));

        return $"default! /* LOM003: Cannot map {sourceTypeName} to {targetTypeName} */";
    }

    private string GetFlattenAssignment(FlattenMapping flatten, string paramName)
    {
        // Build the property access chain (e.g., param.Address?.City)
        var parts = flatten.SourcePropertyPath.Split('.');
        var access = $"{paramName}.{parts[0]}";

        for (int i = 1; i < parts.Length - 1; i++)
        {
            access += $"?.{parts[i]}";
        }

        // Last property with null coalescing
        access += $"?.{parts[^1]}";
        var targetType = flatten.Target.Type;
        var defaultValue = GetDefaultValue(targetType);

        return $"{access} ?? {defaultValue}";
    }

    private string GetDefaultValue(ITypeSymbol type)
    {
        // For reference types and nullable types, use null
        if (type.IsReferenceType || type.NullableAnnotation == NullableAnnotation.Annotated)
        {
            return "null!";
        }

        // For value types, use default
        return $"default({type.ToDisplayString()})";
    }

    private string? TryGetCollectionMapping(ITypeSymbol sourceType, ITypeSymbol targetType, string sourceAccess)
    {
        var sourceElementType = GetCollectionElementType(sourceType);
        var targetElementType = GetCollectionElementType(targetType);

        if (sourceElementType is null || targetElementType is null)
            return null;

        // Generate the element mapping expression
        string elementMapping;
        var sourceElementTypeName = GetTypeNameWithoutNullability(sourceElementType);
        var targetElementTypeName = GetTypeNameWithoutNullability(targetElementType);

        if (SymbolEqualityComparer.Default.Equals(sourceElementType, targetElementType))
        {
            elementMapping = "x";
        }
        else if (_availableMappers.TryGetValue((sourceElementTypeName, targetElementTypeName), out var mapperMethod))
        {
            elementMapping = $"{mapperMethod}(x)";
        }
        else
        {
            // Report error for nested type in collection
            _context.ReportDiagnostic(Diagnostic.Create(
                Diagnostics.MissingNestedMapper,
                Location.None,
                "collection element",
                sourceElementTypeName,
                targetElementTypeName));
            return $"default! /* LOM003: Cannot map collection elements from {sourceElementTypeName} to {targetElementTypeName} */";
        }

        // Determine target collection type and nullability
        var targetTypeString = targetType.ToDisplayString();
        var isTargetNullable = targetType.NullableAnnotation == NullableAnnotation.Annotated;

        // Use null-coalescing for non-nullable targets
        string WrapNullable(string expr, string defaultValue) =>
            isTargetNullable ? expr : $"({expr}) ?? {defaultValue}";

        if (IsArrayType(targetType))
        {
            var arrayExpr = $"{sourceAccess}?.Select(x => {elementMapping}).ToArray()";
            return WrapNullable(arrayExpr, $"Array.Empty<{targetElementType.ToDisplayString()}>()");
        }
        else if (targetTypeString.StartsWith("System.Collections.Generic.List<") ||
                 targetTypeString.StartsWith("global::System.Collections.Generic.List<"))
        {
            var listExpr = $"{sourceAccess}?.Select(x => {elementMapping}).ToList()";
            return WrapNullable(listExpr, $"new List<{targetElementType.ToDisplayString()}>()");
        }
        else if (targetTypeString.StartsWith("System.Collections.Generic.HashSet<") ||
                 targetTypeString.StartsWith("global::System.Collections.Generic.HashSet<"))
        {
            var hashSetExpr = $"{sourceAccess}?.Select(x => {elementMapping}).ToHashSet()";
            return WrapNullable(hashSetExpr, $"new HashSet<{targetElementType.ToDisplayString()}>()");
        }
        else if (targetTypeString.Contains("IEnumerable<") ||
                 targetTypeString.Contains("ICollection<") ||
                 targetTypeString.Contains("IList<") ||
                 targetTypeString.Contains("IReadOnlyList<") ||
                 targetTypeString.Contains("IReadOnlyCollection<"))
        {
            var listExpr = $"{sourceAccess}?.Select(x => {elementMapping}).ToList()";
            return WrapNullable(listExpr, $"new List<{targetElementType.ToDisplayString()}>()");
        }

        // Dictionary handling
        if (IsDictionaryType(sourceType, out var sourceKeyType, out var sourceValueType) &&
            IsDictionaryType(targetType, out var targetKeyType, out var targetValueType))
        {
            var keyMapping = GetElementMappingExpression(sourceKeyType!, targetKeyType!, "k");
            var valueMapping = GetElementMappingExpression(sourceValueType!, targetValueType!, "v");
            var dictExpr = $"{sourceAccess}?.ToDictionary(kvp => {keyMapping.Replace("x", "kvp.Key")}, kvp => {valueMapping.Replace("x", "kvp.Value")})";
            return WrapNullable(dictExpr, $"new Dictionary<{targetKeyType!.ToDisplayString()}, {targetValueType!.ToDisplayString()}>()");
        }

        return null;
    }

    private string GetElementMappingExpression(ITypeSymbol sourceType, ITypeSymbol targetType, string varName)
    {
        if (SymbolEqualityComparer.Default.Equals(sourceType, targetType))
            return varName;

        var sourceTypeName = sourceType.ToDisplayString();
        var targetTypeName = targetType.ToDisplayString();

        if (_availableMappers.TryGetValue((sourceTypeName, targetTypeName), out var mapperMethod))
            return $"{mapperMethod}({varName})";

        return varName;
    }

    private ITypeSymbol? GetCollectionElementType(ITypeSymbol type)
    {
        // Array
        if (type is IArrayTypeSymbol arrayType)
            return arrayType.ElementType;

        // Named type (List<T>, etc.)
        if (type is INamedTypeSymbol namedType)
        {
            // Check for IEnumerable<T>
            foreach (var iface in namedType.AllInterfaces.Prepend(namedType))
            {
                if (iface.OriginalDefinition.ToDisplayString() == "System.Collections.Generic.IEnumerable<T>" &&
                    iface.TypeArguments.Length == 1)
                {
                    return iface.TypeArguments[0];
                }
            }
        }

        return null;
    }

    private bool IsArrayType(ITypeSymbol type) => type is IArrayTypeSymbol;

    private bool IsDictionaryType(ITypeSymbol type, out ITypeSymbol? keyType, out ITypeSymbol? valueType)
    {
        keyType = null;
        valueType = null;

        if (type is INamedTypeSymbol namedType)
        {
            foreach (var iface in namedType.AllInterfaces.Prepend(namedType))
            {
                var displayString = iface.OriginalDefinition.ToDisplayString();
                if ((displayString == "System.Collections.Generic.IDictionary<TKey, TValue>" ||
                     displayString == "System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>") &&
                    iface.TypeArguments.Length == 2)
                {
                    keyType = iface.TypeArguments[0];
                    valueType = iface.TypeArguments[1];
                    return true;
                }
            }
        }

        return false;
    }

    private IMethodSymbol? GetBestConstructor(ITypeSymbol type, List<PropertyMapping> mappings)
    {
        if (type is not INamedTypeSymbol namedType)
            return null;

        var constructors = namedType.Constructors
            .Where(c => c.DeclaredAccessibility == Accessibility.Public && !c.IsStatic)
            .OrderByDescending(c => c.Parameters.Length)
            .ToList();

        // Prefer parameterized constructor that matches property names
        foreach (var ctor in constructors)
        {
            if (ctor.Parameters.Length == 0)
                continue;

            var matchCount = ctor.Parameters.Count(p =>
                mappings.Any(m => string.Equals(m.Target.Name, p.Name, StringComparison.OrdinalIgnoreCase)));

            if (matchCount == ctor.Parameters.Length)
            {
                return ctor;
            }
        }

        // Fall back to parameterless constructor
        return constructors.FirstOrDefault(c => c.Parameters.Length == 0);
    }

    private static IEnumerable<IPropertySymbol> GetAllProperties(ITypeSymbol type)
    {
        var properties = new List<IPropertySymbol>();
        var current = type;

        while (current is not null)
        {
            properties.AddRange(current.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => !p.IsStatic && !p.IsIndexer));

            current = current.BaseType;
        }

        return properties;
    }

    private static string GetAccessibilityString(Accessibility accessibility) => accessibility switch
    {
        Accessibility.Public => "public",
        Accessibility.Internal => "internal",
        Accessibility.Protected => "protected",
        Accessibility.ProtectedOrInternal => "protected internal",
        Accessibility.ProtectedAndInternal => "private protected",
        Accessibility.Private => "private",
        _ => "internal"
    };

    private void AppendLine(string? text = null)
    {
        if (string.IsNullOrEmpty(text))
        {
            _sb.AppendLine();
        }
        else
        {
            _sb.Append(new string(' ', _indentLevel * 4));
            _sb.AppendLine(text);
        }
    }

    private sealed record PropertyMapping(
        IPropertySymbol Source,
        IPropertySymbol Target,
        string? Transform);

    private sealed record FlattenMapping(
        string SourcePropertyPath,
        IPropertySymbol Target,
        ITypeSymbol ResolvedSourceType);
}
